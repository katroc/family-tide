// Stage 4.2: Service Abstraction Layer
// Abstract interface that allows switching between SQLite and Supabase

import { 
  FamilyMember, 
  NewFamilyMember, 
  Chore, 
  NewChore, 
  EventItem, 
  Reward, 
  NewReward, 
  FamilyDetails, 
  ChoreType, 
  Routine, 
  DailyRoutineProgress, 
  TabId 
} from './types';

/**
 * Abstract interface for data services
 * Both SQLite and Supabase services implement this interface
 */
export interface IDataService {
  // Core initialization
  initialize(): Promise<void>;
  
  // Family Management
  getFamilyDetails(): Promise<FamilyDetails>;
  saveFamilyDetails(details: FamilyDetails): Promise<void>;
  getFamilyPhoto(): Promise<string | null>;
  saveFamilyPhoto(photoDataUrl: string): Promise<void>;
  
  // Family Members
  getFamilyMembers(): Promise<FamilyMember[]>;
  addFamilyMember(member: NewFamilyMember): Promise<FamilyMember>;
  updateFamilyMember(member: FamilyMember): Promise<void>;
  deleteFamilyMember(id: number): Promise<void>;
  
  // Chores
  getChores(): Promise<Chore[]>;
  addChore(chore: NewChore): Promise<Chore>;
  updateChore(chore: Chore): Promise<void>;
  deleteChore(id: number): Promise<void>;
  getChoreTypes(): Promise<ChoreType[]>;
  updateChoreTypes(choreTypes: ChoreType[]): Promise<ChoreType[]>;
  
  // Events
  getEvents(): Promise<EventItem[]>;
  addEvent(event: Omit<EventItem, 'id'>): Promise<EventItem>;
  updateEvent(event: EventItem): Promise<void>;
  deleteEvent(id: number): Promise<void>;
  
  // Rewards
  getRewards(): Promise<Reward[]>;
  addReward(reward: NewReward): Promise<Reward>;
  updateReward(reward: Reward): Promise<void>;
  deleteReward(id: number): Promise<void>;
  
  // Routines
  getRoutines(): Promise<Routine[]>;
  addRoutine(routine: Omit<Routine, 'id'>): Promise<Routine>;
  updateRoutines(routines: Routine[]): Promise<Routine[]>;
  deleteRoutine(id: string): Promise<void>;
  
  // Daily Routine Progress
  getDailyRoutineProgress(date: string): Promise<DailyRoutineProgress[]>;
  upsertDailyRoutineProgress(progress: DailyRoutineProgress): Promise<void>;
  
  // App State
  saveActiveTab(tabId: TabId): Promise<void>;
  getActiveTab(): Promise<TabId>;
  
  // Service metadata
  getServiceInfo(): Promise<{
    type: 'sqlite' | 'supabase';
    version: string;
    status: 'active' | 'fallback';
  }>;
}

/**
 * Feature flags for service selection
 */
interface ServiceConfig {
  useSupabase: boolean;
  allowFallback: boolean;
  debugMode: boolean;
}

/**
 * Service Manager - Controls which service to use
 */
class ServiceManager {
  private config: ServiceConfig;
  private activeService: IDataService | null = null;
  private sqliteService: IDataService | null = null;
  private supabaseService: IDataService | null = null;

  constructor(config: Partial<ServiceConfig> = {}) {
    this.config = {
      useSupabase: false, // Start with SQLite by default
      allowFallback: true,
      debugMode: true,
      ...config
    };
    
    console.log('üîß ServiceManager initialized with config:', this.config);
  }

  async initialize(): Promise<IDataService> {
    console.log('üöÄ ServiceManager: Initializing data services...');
    
    try {
      // Always initialize SQLite service as fallback
      const { dataService: sqliteDataService } = await import('./dataService');
      await sqliteDataService.initialize();
      this.sqliteService = sqliteDataService as unknown as IDataService;
      console.log('‚úÖ SQLite service initialized');
      
      if (this.config.useSupabase) {
        try {
          // Try to initialize Supabase service
          const { SupabaseDataService } = await import('./supabaseDataService');
          this.supabaseService = new SupabaseDataService();
          await this.supabaseService.initialize();
          console.log('‚úÖ Supabase service initialized');
          
          this.activeService = this.supabaseService;
          console.log('üéØ Using Supabase as primary service');
        } catch (error) {
          console.error('‚ùå Supabase initialization failed:', error);
          
          if (this.config.allowFallback) {
            this.activeService = this.sqliteService;
            console.log('üîÑ Falling back to SQLite service');
          } else {
            throw error;
          }
        }
      } else {
        this.activeService = this.sqliteService;
        console.log('üéØ Using SQLite as primary service (configured)');
      }
      
      return this.activeService;
      
    } catch (error) {
      console.error('üí• ServiceManager initialization failed:', error);
      throw error;
    }
  }

  getActiveService(): IDataService {
    if (!this.activeService) {
      throw new Error('ServiceManager not initialized. Call initialize() first.');
    }
    return this.activeService;
  }

  async switchToSupabase(): Promise<boolean> {
    console.log('üîÑ Switching to Supabase service...');
    
    try {
      if (!this.supabaseService) {
        const { SupabaseDataService } = await import('./supabaseDataService');
        this.supabaseService = new SupabaseDataService();
        await this.supabaseService.initialize();
      }
      
      this.activeService = this.supabaseService;
      this.config.useSupabase = true;
      console.log('‚úÖ Switched to Supabase service');
      return true;
    } catch (error) {
      console.error('‚ùå Failed to switch to Supabase:', error);
      return false;
    }
  }

  async switchToSQLite(): Promise<boolean> {
    console.log('üîÑ Switching to SQLite service...');
    
    if (this.sqliteService) {
      this.activeService = this.sqliteService;
      this.config.useSupabase = false;
      console.log('‚úÖ Switched to SQLite service');
      return true;
    } else {
      console.error('‚ùå SQLite service not available');
      return false;
    }
  }

  getConfig(): ServiceConfig {
    return { ...this.config };
  }

  updateConfig(newConfig: Partial<ServiceConfig>): void {
    this.config = { ...this.config, ...newConfig };
    console.log('üîß ServiceManager config updated:', this.config);
  }
}

// Global service manager instance
export const serviceManager = new ServiceManager();

// Convenience proxy that forwards all calls to the active service
export const unifiedDataService = new Proxy({} as IDataService, {
  get(target, prop) {
    const activeService = serviceManager.getActiveService();
    const method = activeService[prop as keyof IDataService];
    
    if (typeof method === 'function') {
      return method.bind(activeService);
    }
    
    return method;
  }
});

console.log('üì¶ Service Abstraction Layer loaded successfully');
